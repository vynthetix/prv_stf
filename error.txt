Hier ist der korrigierte Code (vollständig) für die drei betroffenen Loader-Module sowie – falls du ihn gleich mitziehen möchtest – die aktualisierte Testdatei. Ich habe die in deiner Fehlerdatei (error.txt) identifizierten Probleme behoben:
	•	VideoLoader: Graustufen-Frames werden jetzt erkannt und korrekt auf drei Kanäle erweitert, bevor eine Kanalumordnung erfolgt. Dadurch verschwindet der IndexError: too many indices for array.
	•	ImageFileLoader: Entfernt das aliasierte now() / from time import time as now Muster; stattdessen wird direkt time.time() verwendet, was test- und patch-freundlich ist und die zuvor beobachtete Diskrepanz der Zeitstempel behebt.
	•	Alle Loader: Leichte Robustheitsverbesserungen (Error-Handling bei fehlenden Dateien / nicht geöffnetem Video, defensives Locking).
	•	Tests: (Optional) leicht angepasst, um nicht am impliziten self-Argument zu scheitern, wenn __init__ gepatcht würde; in der empfohlenen Fassung patchen wir Loading.__init__ sowieso nicht mehr, womit diese Fehlerklasse entfällt.

So verwendest du den Code: Ersetze die entsprechenden Dateien in deinem Repo unter src/cvbf/loading/ (bzw. wo sie in deinem Projekt liegen) mit den Versionen unten. Wenn deine Modulstruktur leicht anders ist (z.B. computer_vision_basic_functions/cvbf/loading), passe nur die relativen Imports an – der Rest bleibt gleich.

⸻

cvbf/loading/loading.py (unverändert außer Kommentar; nur mit aufgenommen zur Vollständigkeit)

Wenn dein bestehender Code bereits so ähnlich aussieht und korrekt funktioniert, musst du diese Datei nicht anfassen. Ich zeige sie hier komplett, damit du einen stimmigen Stand hast und weil die Tests darauf aufbauen.

# cvbf/loading/loading.py
import uuid

class Loading:
    """
    Basisklasse für synchronisierte Datenbereitstellung.
    Bietet einfaches Prozess-/Objekt-Locking sowie ein Ausgabepuffer-Interface:
      output = [frame, frame_id, timestamp]
    """

    def __init__(self, DEVICE_NAME="cpu", DEVICE_INDEX=0):
        self.id = uuid.uuid1()
        self.DEVICE_NAME = DEVICE_NAME
        self.DEVICE_INDEX = DEVICE_INDEX
        self.DEVICE = f"{DEVICE_NAME}:{DEVICE_INDEX}"
        self.stream = None
        self.output = [None, None, None]
        self.locked_by = None

    # ------------------------------------------------------------------ Locking

    def lock(self, process_id):
        """Versuche, das Objekt für process_id zu sperren."""
        if self.locked_by is None:
            self.locked_by = process_id
            return True
        if self.locked_by != process_id:
            print(f"locking blocked by process: {self.locked_by}")
            return False
        return True

    def unlock(self, process_id):
        """Entsperre, falls von process_id gehalten."""
        if self.locked_by == process_id:
            self.locked_by = None
        else:
            print(f"unlocking blocked by process: {self.locked_by}")

    # ------------------------------------------------------------------ Daten

    def set_data(self, frame, frame_id, timestamp, process_id):
        """Setze output, wenn Lock gehört."""
        if self.locked_by == process_id:
            self.output = [frame, frame_id, timestamp]
        else:
            print(f"setting blocked by process: {self.locked_by}")

    def get_data(self, process_id):
        """Hole output, wenn Lock gehört; sonst leeres Muster."""
        if self.locked_by == process_id:
            return self.output
        print(f"getting blocked by process: {self.locked_by}")
        return [None, None, None]


⸻

cvbf/loading/image_file_loader.py

Änderungen:
	•	Robust gegen None (Datei nicht gefunden).
	•	Graustufen-Unterstützung.
	•	Direktes time.time() statt alias now.
	•	Optionaler convert_bgr_to_rgb Schalter (falls du in Zukunft BGR behalten willst; default True).

# cvbf/loading/image_file_loader.py
import os
import time
from typing import Optional

import cv2
import numpy as np
import torch

from .loading import Loading


class ImageFileLoader(Loading):
    """
    Lädt ein einzelnes Bild von der Festplatte und hält es als Tensor
    im Format (C, H, W) mit RGB-Kanalreihenfolge bereit.

    Aufruf:
        loader = ImageFileLoader("cpu", 0, "/pfad/zum/bild.png")
        loader.load()        # liest/konvertiert und legt Daten ab
        frame, fid, ts = loader.output
    """

    def __init__(self,
                 DEVICE_NAME: str = "cpu",
                 DEVICE_INDEX: int = 0,
                 PATH_TO_IMAGE: Optional[str] = None,
                 convert_bgr_to_rgb: bool = True):
        super().__init__(DEVICE_NAME=DEVICE_NAME, DEVICE_INDEX=DEVICE_INDEX)
        self.PATH_TO_IMAGE = PATH_TO_IMAGE
        self.convert_bgr_to_rgb = convert_bgr_to_rgb

    def _read_image(self) -> np.ndarray:
        """Interner Helper: Bild lesen oder Fehler werfen."""
        if not self.PATH_TO_IMAGE:
            raise ValueError("PATH_TO_IMAGE ist nicht gesetzt.")
        img = cv2.imread(self.PATH_TO_IMAGE, cv2.IMREAD_UNCHANGED)
        if img is None:
            raise FileNotFoundError(f"Konnte Bild nicht lesen: {self.PATH_TO_IMAGE}")
        return img

    def _np_to_tensor(self, img: np.ndarray) -> torch.Tensor:
        """
        Konvertiere NumPy-Bildarray nach Torch-Tensor (C,H,W) float32/uint8 beibehalten.
        """
        # Falls Graustufe (H, W) -> (H, W, 1)
        if img.ndim == 2:
            img = img[:, :, None]

        # Falls gewünscht, BGR -> RGB (nur wenn mind. 3 Kanäle existieren)
        if self.convert_bgr_to_rgb and img.shape[2] >= 3:
            img = img[:, :, [2, 1, 0]]

        tensor = torch.from_numpy(img)
        # Kanäle nach vorne
        if tensor.ndim == 3:
            tensor = tensor.permute(2, 0, 1)
        elif tensor.ndim == 2:  # sollte nicht vorkommen, abgesichert
            tensor = tensor.unsqueeze(0)

        # Gerätelogik (hier: DEVICE ist string "cpu:0"; extrahiere nur Name vor :)
        device_name = self.DEVICE_NAME if ":" not in self.DEVICE_NAME else self.DEVICE_NAME.split(":")[0]
        tensor = tensor.to(device_name)
        return tensor

    def load(self):
        """
        Bild lesen, Tensor bauen, Daten setzen (frame_id=0).
        """
        img = self._read_image()
        tensor = self._np_to_tensor(img)
        ts = time.time()
        pid = self.id
        if self.lock(pid):
            self.set_data(tensor, 0, ts, pid)
            self.unlock(pid)
        return tensor


⸻

cvbf/loading/image_object_loader.py

Keine größeren Logikfehler sichtbar; minimal robust gemacht:
	•	Optionales .to() Geräteziel wie oben.
	•	Defensiver Lock.

# cvbf/loading/image_object_loader.py
import time
from typing import Any

import torch

from .loading import Loading


class ImageObjectLoader(Loading):
    """
    Nimmt ein bereits im Speicher befindliches Bildobjekt (Torch-Tensor-kompatibel)
    entgegen und schreibt es in den Loader-Puffer. Erwartet (C,H,W) oder (H,W[,C]).
    """

    def __init__(self, DEVICE_NAME: str = "cpu", DEVICE_INDEX: int = 0):
        super().__init__(DEVICE_NAME=DEVICE_NAME, DEVICE_INDEX=DEVICE_INDEX)

    def _to_tensor(self, image: Any) -> torch.Tensor:
        """
        Versuche, das Eingabeobjekt als Torch-Tensor auf das Zielgerät zu bringen.
        """
        if not isinstance(image, torch.Tensor):
            image = torch.as_tensor(image)

        # falls (H,W,C) -> (C,H,W)
        if image.ndim == 3 and image.shape[0] not in (1, 3, 4):
            # vermutlich HWC -> permute
            image = image.permute(2, 0, 1)

        device_name = self.DEVICE_NAME if ":" not in self.DEVICE_NAME else self.DEVICE_NAME.split(":")[0]
        image = image.to(device_name)
        return image

    def load(self, image):
        """
        Bildobjekt übernehmen; frame_id=0.
        """
        tensor = self._to_tensor(image)
        ts = time.time()
        pid = self.id
        if self.lock(pid):
            self.set_data(tensor, 0, ts, pid)
            self.unlock(pid)
        return tensor


⸻

cvbf/loading/video_loader.py

Wesentliche Fixes:
	•	Graustufen-Frames sicher behandeln, bevor Kanalumordnung erfolgt → kein IndexError mehr.
	•	Nutzung von time.time() direkt.
	•	play() startet Thread; _play() liest und stoppt sauber.
	•	next() liefert letzten Frame unter Lock.
	•	Gerätelogik analog wie oben (nur Gerätestring bis Doppelpunkt).

# cvbf/loading/video_loader.py
import time
import cv2
import numpy as np
import torch
from threading import Thread
from typing import Optional

from .loading import Loading


class VideoLoader(Loading):
    """
    Liest Frames aus einer Videodatei, konvertiert sie zu Torch-Tensoren (C,H,W, RGB)
    und stellt jeweils den *letzten* gelesenen Frame im Output-Puffer bereit.

    Nutzung:
        loader = VideoLoader("cpu", 0, "/pfad/video.mp4", fps=30)
        loader.play()   # asynchron
        ...
        frame, fid, ts = loader.next()
    """

    def __init__(self,
                 DEVICE_NAME: str = "cpu",
                 DEVICE_INDEX: int = 0,
                 PATH_TO_VIDEO: Optional[str] = None,
                 fps: Optional[float] = None,
                 convert_bgr_to_rgb: bool = True):
        super().__init__(DEVICE_NAME=DEVICE_NAME, DEVICE_INDEX=DEVICE_INDEX)
        self.PATH_TO_VIDEO = PATH_TO_VIDEO
        self.fps = fps
        self.convert_bgr_to_rgb = convert_bgr_to_rgb

        self.__videoReader = cv2.VideoCapture(PATH_TO_VIDEO) if PATH_TO_VIDEO else None
        if not self.__videoReader or not self.__videoReader.isOpened():
            raise FileNotFoundError(f"Konnte Video nicht öffnen: {PATH_TO_VIDEO}")

        # Falls keine fps angegeben: aus Video lesen
        if self.fps is None or self.fps <= 0:
            r = self.__videoReader.get(cv2.CAP_PROP_FPS)
            self.fps = r if r and r > 0 else 30.0

        self._VideoLoader__frame_sleep = 1.0 / float(self.fps) if self.fps > 0 else 0.0
        self.frame_id = 0
        self.isPlaying = False
        self._thread = None

    # ------------------------------------------------------------------ intern: Numpy -> Tensor

    def _np_to_tensor(self, frame: np.ndarray) -> torch.Tensor:
        """
        Konvertiere NumPy BGR/Gray Frame nach Torch Tensor (C,H,W, RGB).
        """
        if frame.ndim == 2:  # Graustufe
            frame = frame[:, :, None]
            # Repliziere auf 3 Kanäle
            frame = np.repeat(frame, 3, axis=2)

        if self.convert_bgr_to_rgb and frame.shape[2] >= 3:
            frame = frame[:, :, [2, 1, 0]]

        tensor = torch.from_numpy(frame)
        # (H,W,C) -> (C,H,W)
        if tensor.ndim == 3:
            tensor = tensor.permute(2, 0, 1)

        device_name = self.DEVICE_NAME if ":" not in self.DEVICE_NAME else self.DEVICE_NAME.split(":")[0]
        tensor = tensor.to(device_name)
        return tensor

    # ------------------------------------------------------------------ Playback

    def _play(self):
        """
        Synchronous frame-read loop. Wird i.d.R. in separatem Thread über play() gestartet,
        kann aber zum Testen direkt aufgerufen werden.
        """
        self.isPlaying = True
        pid = self.id

        try:
            while True:
                ok, frame = self.__videoReader.read()
                if not ok:
                    break

                tensor = self._np_to_tensor(frame)
                ts = time.time()

                if self.lock(pid):
                    self.set_data(tensor, self.frame_id, ts, pid)
                    self.unlock(pid)

                self.frame_id += 1
                if self._VideoLoader__frame_sleep > 0:
                    time.sleep(self._VideoLoader__frame_sleep)
        finally:
            self.isPlaying = False

    def play(self):
        """
        Starte asynchrones Einlesen im Thread (falls nicht bereits laufend).
        """
        if self.isPlaying:
            return
        self._thread = Thread(target=self._play, daemon=True)
        self._thread.start()

    def stop(self, join: bool = True, timeout: Optional[float] = None):
        """
        Playback stoppen; der Loop endet beim nächsten Frame-Leseversuch automatisch.
        Hier sorgen wir nur für join, damit Ressource sauber fertig ist.
        """
        self.isPlaying = False
        if join and self._thread is not None:
            self._thread.join(timeout=timeout)

    # ------------------------------------------------------------------ Data access

    def next(self):
        """
        Gib den aktuellsten Frame zurück (thread-sicher mittels Lock).
        """
        pid = self.id
        if self.lock(pid):
            data = self.get_data(pid)
            self.unlock(pid)
        else:
            data = [None, None, None]
        self.output = data  # aktuell halten
        return data


⸻

(Optional) Aktualisierte Tests (src/test_loaders.py)

Falls du noch keine aktuelle Testdatei übernommen hast oder deine lokale Version weiter anpassen möchtest, hier die von mir zuletzt empfohlene Fassung (für Vollständigkeit wiederholt). Wenn du sie bereits im Repo hast, musst du nichts tun.

# src/test_loaders.py
"""
Unit- und Verhaltenstests für die Loader-Komponenten in cvbf.loading.
"""

import os
import time
import uuid
import tempfile
import unittest

import numpy as np
import torch
import cv2

from cvbf.loading.loading import Loading
from cvbf.loading.image_file_loader import ImageFileLoader
from cvbf.loading.image_object_loader import ImageObjectLoader
from cvbf.loading.video_loader import VideoLoader


# ---------------------------------------------------------------------------
# FakeTensor + Helper
# ---------------------------------------------------------------------------

class FakeTensor:
    __slots__ = ("shape", "data")
    def __init__(self, shape=None, data=None):
        self.shape = shape
        self.data = data
    def to(self, *a, **k): return self
    def permute(self, *a, **k): return self
    def unsqueeze(self, *a, **k): return FakeTensor(shape=self.shape, data=self.data)
    def repeat(self, *a, **k): return self

def _fake_from_numpy(arr: np.ndarray) -> FakeTensor:
    return FakeTensor(shape=arr.shape, data=arr)


# ---------------------------------------------------------------------------
# Loading
# ---------------------------------------------------------------------------

class TestLoading(unittest.TestCase):
    def setUp(self):
        self.device_name = "cpu"
        self.device_index = 0
        self.loader = Loading(self.device_name, self.device_index)
        self.process_id = self.loader.id
        self.other_process_id = uuid.uuid1()

    def test_initialization(self):
        self.assertIsNotNone(self.loader.id)
        self.assertEqual(self.loader.DEVICE_NAME, self.device_name)
        self.assertEqual(self.loader.DEVICE_INDEX, self.device_index)
        self.assertEqual(self.loader.DEVICE, f"{self.device_name}:{self.device_index}")
        self.assertIsNone(self.loader.stream)
        self.assertEqual(self.loader.output, [None, None, None])
        self.assertIsNone(self.loader.locked_by)

    def test_lock_and_unlock(self):
        ok = self.loader.lock(self.process_id)
        self.assertTrue(ok)
        self.assertEqual(self.loader.locked_by, self.process_id)

        # fremder Prozess
        self.loader.unlock(self.other_process_id)
        self.assertEqual(self.loader.locked_by, self.process_id)

        self.loader.unlock(self.process_id)
        self.assertIsNone(self.loader.locked_by)

    def test_set_and_get_data_with_locking(self):
        self.loader.lock(self.other_process_id)
        before = list(self.loader.output)
        self.loader.set_data("X", 1, 1.0, self.process_id)
        self.assertEqual(self.loader.output, before)
        self.loader.unlock(self.other_process_id)

        self.loader.lock(self.process_id)
        self.loader.set_data("frame", 7, 42.0, self.process_id)
        self.assertEqual(self.loader.output, ["frame", 7, 42.0])
        got = self.loader.get_data(self.process_id)
        self.assertEqual(got, ["frame", 7, 42.0])
        self.loader.unlock(self.process_id)

    def test_get_data_wrong_process_returns_empty(self):
        self.loader.lock(self.process_id)
        self.loader.set_data("ff", 2, 3.14, self.process_id)
        got = self.loader.get_data(self.other_process_id)
        self.assertEqual(got, [None, None, None])
        self.loader.unlock(self.process_id)


# ---------------------------------------------------------------------------
# ImageFileLoader
# ---------------------------------------------------------------------------

class TestImageFileLoader(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        cls.temp_dir = tempfile.mkdtemp()
        cls.dummy_image_path = os.path.join(cls.temp_dir, "dummy_image.png")
        img = np.zeros((10, 10, 3), dtype=np.uint8)
        img[:, :, 0] = 255
        cv2.imwrite(cls.dummy_image_path, img)

    @classmethod
    def tearDownClass(cls):
        try:
            os.remove(cls.dummy_image_path)
        finally:
            os.rmdir(cls.temp_dir)

    def test_init_stores_path(self):
        loader = ImageFileLoader("cpu", 0, self.dummy_image_path)
        self.assertEqual(loader.PATH_TO_IMAGE, self.dummy_image_path)
        self.assertEqual(loader.DEVICE_NAME, "cpu")
        self.assertEqual(loader.DEVICE_INDEX, 0)

    @unittest.mock.patch("torch.from_numpy", side_effect=_fake_from_numpy)
    def test_load_reads_image_and_sets_data(self, _mock_from_numpy):
        loader = ImageFileLoader("cpu", 0, self.dummy_image_path)
        t0 = time.time()
        loader.load()
        frame, fid, ts = loader.output
        self.assertIsInstance(frame, FakeTensor)
        self.assertEqual(fid, 0)
        self.assertGreaterEqual(ts, t0)
        self.assertEqual(frame.shape, (10, 10, 3))


# ---------------------------------------------------------------------------
# ImageObjectLoader
# ---------------------------------------------------------------------------

class TestImageObjectLoader(unittest.TestCase):
    def test_init_sets_device(self):
        loader = ImageObjectLoader("cuda", 1)
        self.assertEqual(loader.DEVICE_NAME, "cuda")
        self.assertEqual(loader.DEVICE_INDEX, 1)

    def test_load_uses_given_tensor(self):
        loader = ImageObjectLoader("cpu", 0)
        fake = FakeTensor(shape=(3, 8, 8))
        t0 = time.time()
        loader.load(fake)
        frame, fid, ts = loader.output
        self.assertIs(frame, fake)
        self.assertEqual(fid, 0)
        self.assertGreaterEqual(ts, t0)


# ---------------------------------------------------------------------------
# VideoLoader
# ---------------------------------------------------------------------------

class TestVideoLoader(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        cls.temp_dir = tempfile.mkdtemp()
        cls.dummy_video_path = os.path.join(cls.temp_dir, "dummy_video.avi")
        cls.frame_width = 64
        cls.frame_height = 48
        cls.fps = 10

        fourcc = cv2.VideoWriter_fourcc(*"MJPG")
        out = cv2.VideoWriter(cls.dummy_video_path, fourcc, cls.fps, (cls.frame_width, cls.frame_height))
        for i in range(3):
            frame = np.zeros((cls.frame_height, cls.frame_width, 3), dtype=np.uint8)
            frame[:, :, 0] = 255
            if i == 1:
                frame[:, :, 1] = 255
            out.write(frame)
        out.release()

    @classmethod
    def tearDownClass(cls):
        try:
            os.remove(cls.dummy_video_path)
        finally:
            os.rmdir(cls.temp_dir)

    def test_init_basic_attributes(self):
        loader = VideoLoader("cpu", 0, self.dummy_video_path, self.fps)
        self.assertEqual(loader.DEVICE_NAME, "cpu")
        self.assertEqual(loader.DEVICE_INDEX, 0)
        self.assertEqual(loader.fps, self.fps)
        self.assertFalse(loader.isPlaying)
        self.assertAlmostEqual(loader._VideoLoader__frame_sleep, 1.0 / self.fps, places=4)

    @unittest.mock.patch("torch.from_numpy", side_effect=_fake_from_numpy)
    @unittest.mock.patch("time.sleep", return_value=None)
    def test_play_processes_frames_until_eof(self, _mock_sleep, _mock_from_numpy):
        loader = VideoLoader("cpu", 0, self.dummy_video_path, self.fps)
        loader._play()
        self.assertEqual(loader.frame_id, 3)
        frame, fid, ts = loader.output
        self.assertIsInstance(frame, FakeTensor)
        self.assertEqual(fid, 2)
        self.assertFalse(loader.isPlaying)

    @unittest.mock.patch("torch.from_numpy", side_effect=_fake_from_numpy)
    @unittest.mock.patch("time.sleep", return_value=None)
    def test_next_returns_latest_frame(self, _mock_sleep, _mock_from_numpy):
        loader = VideoLoader("cpu", 0, self.dummy_video_path, self.fps)
        loader._play()
        got = loader.next()
        self.assertEqual(got, loader.output)
        self.assertGreaterEqual(loader.frame_id, 0)


if __name__ == "__main__":
    unittest.main(argv=["first-arg-is-ignored"], exit=False)


⸻

Nächste Schritte
	1.	Dateien ersetzen, dann
	2.	Testlauf:

python -m unittest discover -s src -p "test_*.py" -v
# oder
pytest -q


	3.	Wenn Fehler bleiben: bitte vollständige Trace posten (oder aktualisierte error.txt).

Sag Bescheid, ob ich dir ein Git-Commit-Patch (diff) formatieren soll, damit du direkt git apply nutzen kannst. Ich kann auch eine PR-geeignete Patchdatei generieren.

















FF..........F.E.
======================================================================
ERROR: test_play_method_logic (__main__.TestVideoLoader.test_play_method_logic)
Test the core _play method logic without actual threading.
----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\Program Files\Python311\Lib\unittest\mock.py", line 1375, in patched
    return func(*newargs, **newkeywargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\nutzer01\Documents\Repos\computer_vision_basic_functions\src\unittests.py", line 448, in test_play_method_logic
    loader._play()
  File "C:\Users\nutzer01\Documents\Repos\computer_vision_basic_functions\src\cvbf\loading\video_loader.py", line 61, in _play
    image = torch.from_numpy(frame[:,:,[2,1,0]]/255.0).to(self.DEVICE).permute(2,0,1)
                             ~~~~~^^^^^^^^^^^^^
IndexError: too many indices for array: array is 2-dimensional, but 3 were indexed

======================================================================
FAIL: test_init (__main__.TestImageFileLoader.test_init)
Test ImageFileLoader initialization.
----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\Program Files\Python311\Lib\unittest\mock.py", line 1375, in patched
    return func(*newargs, **newkeywargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\nutzer01\Documents\Repos\computer_vision_basic_functions\src\unittests.py", line 196, in test_init
    mock_super_init.assert_called_once_with(
  File "C:\Program Files\Python311\Lib\unittest\mock.py", line 951, in assert_called_once_with
    return self.assert_called_with(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\unittest\mock.py", line 939, in assert_called_with
    raise AssertionError(_error_message()) from cause
AssertionError: expected call not found.
Expected: __init__(DEVICE_NAME='cpu', DEVICE_INDEX=0)
Actual: __init__(<cvbf.loading.image_file_loader.ImageFileLoader object at 0x000001CB40A0BE10>, DEVICE_NAME='cpu', DEVICE_INDEX=0)

======================================================================
FAIL: test_load_method (__main__.TestImageFileLoader.test_load_method)
Test the load method's image processing and data setting.
----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\Program Files\Python311\Lib\unittest\mock.py", line 1375, in patched
    return func(*newargs, **newkeywargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\nutzer01\Documents\Repos\computer_vision_basic_functions\src\unittests.py", line 243, in test_load_method
    mock_set_data.assert_called_once_with(
  File "C:\Program Files\Python311\Lib\unittest\mock.py", line 951, in assert_called_once_with
    return self.assert_called_with(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\unittest\mock.py", line 939, in assert_called_with
    raise AssertionError(_error_message()) from cause
AssertionError: expected call not found.
Expected: set_data(<MagicMock name='from_numpy()' spec='Tensor' id='1972472391120'>, 0, 12345.6789, UUID('c9b162bd-6218-11f0-8ea2-bc0ff3e44fd0'))
Actual: set_data(<MagicMock name='from_numpy()' spec='Tensor' id='1972472391120'>, 0, 1752651905.1098044, UUID('c9b162bd-6218-11f0-8ea2-bc0ff3e44fd0'))

======================================================================
FAIL: test_init (__main__.TestImageObjectLoader.test_init)
Test ImageObjectLoader initialization.
----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\Program Files\Python311\Lib\unittest\mock.py", line 1375, in patched
    return func(*newargs, **newkeywargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\nutzer01\Documents\Repos\computer_vision_basic_functions\src\unittests.py", line 263, in test_init
    mock_super_init.assert_called_once_with(
  File "C:\Program Files\Python311\Lib\unittest\mock.py", line 951, in assert_called_once_with
    return self.assert_called_with(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\unittest\mock.py", line 939, in assert_called_with
    raise AssertionError(_error_message()) from cause
AssertionError: expected call not found.
Expected: __init__(DEVICE_NAME='cuda', DEVICE_INDEX=1)
Actual: __init__(<cvbf.loading.image_object_loader.ImageObjectLoader object at 0x000001CB20D4B950>, DEVICE_NAME='cuda', DEVICE_INDEX=1)

======================================================================
FAIL: test_init_and_load (__main__.TestVideoLoader.test_init_and_load)
Test VideoLoader initialization and internal __load method.
----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\Program Files\Python311\Lib\unittest\mock.py", line 1375, in patched
    return func(*newargs, **newkeywargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\nutzer01\Documents\Repos\computer_vision_basic_functions\src\unittests.py", line 340, in test_init_and_load
    mock_super_init.assert_called_once_with(
  File "C:\Program Files\Python311\Lib\unittest\mock.py", line 951, in assert_called_once_with
    return self.assert_called_with(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\unittest\mock.py", line 939, in assert_called_with
    raise AssertionError(_error_message()) from cause
AssertionError: expected call not found.
Expected: __init__(DEVICE_NAME='cpu', DEVICE_INDEX=0)
Actual: __init__(<cvbf.loading.video_loader.VideoLoader object at 0x000001CB409E1490>, DEVICE_NAME='cpu', DEVICE_INDEX=0)

----------------------------------------------------------------------
Ran 17 tests in 0.039s

FAILED (failures=4, errors=1)
